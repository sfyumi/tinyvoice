---
description: TinyAgent architecture -- three-layer voice agent with soul, skills, and tools
alwaysApply: true
---

# TinyAgent Architecture Rule

## Three Layers
1. **Voice Layer**: ASR (Soniox) ← voice in; TTS (Qwen) → voice out. Single WebSocket, JSON + binary PCM.
2. **Agent Brain**: Agent loop (LLM + tool call cycles), 13 tools, 5 skills. Max 5 tool rounds per turn.
3. **Persistent Soul**: SOUL.md (identity), USER.md (user profile), MEMORY.md (conversation history). All in `soul/` directory.

## Prompt Hierarchy
Soul → User Profile → Agent Instructions → Active Skill Instructions → Available Skills Metadata → Tools

## State Machine
- `idle → listening → thinking → [executing] → speaking → listening`
- `executing` entered on tool calls; returns to `thinking` after result
- Interrupt from `speaking` or `executing` → `listening`

## Agent Loop (app/agent.py)
- LLM responds with either text (→ TTS) or tool_calls (→ execute → loop)
- Cancel via `asyncio.Event` coordinates agent loop, tools, and TTS
- After all tool rounds, final text response goes to TTS

## Soul & Memory (app/memory.py)
- SoulManager loads SOUL.md + USER.md at session start → system prompt
- MEMORY.md on-demand via `recall_memory` tool
- USER.md updated via `update_user_profile` tool
- Session summaries auto-appended to MEMORY.md at session end

## Skills (app/skills.py)
- Agent Skills spec (agentskills.io): SKILL.md with YAML frontmatter
- Progressive disclosure: metadata always loaded, full body on activation
- LLM activates/deactivates via tools

## Tools (app/tools.py)
- 13 built-in: run_python, list_directory, search_files, read_file, write_file, web_search, browse_web (optional), calculate, get_datetime, recall_memory, update_user_profile, save_note, activate_skill
- JSON Schema parameters, async execute, OpenAI function-calling format

## ASR Rules
- Soniox `<end>` token = utterance boundary → `_on_sentence()` → clear buffer
- Stream interim/final transcript to frontend continuously

## TTS Rules
- DashScope sync SDK bridged via threading.Thread + queue.Queue
- Mid-stream cancel: `cancel_response` → close WebSocket → `threading.Event`

## Interrupt Flow
- Set `cancel_event` → `tts.cancel()` → cancel turn task → state `listening`

## Config
- pydantic-settings from `.env`, cached `get_settings()`
- Each WebSocket connection: own SkillManager + ToolRegistry + SoulManager
